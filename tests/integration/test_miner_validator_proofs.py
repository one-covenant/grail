"""Integration test for miner-validator GRAIL proof verification.

Tests that proofs generated by the miner's computation pipeline
pass the validator's verification pipeline.
"""

from __future__ import annotations

import hashlib
import os
from typing import Any

import pytest
import torch
from transformers import AutoModelForCausalLM, AutoTokenizer

pytestmark = [
    pytest.mark.integration,
    pytest.mark.skipif(
        not torch.cuda.is_available() or os.getenv("SKIP_GPU_TESTS") == "1",
        reason="GPU required for proof integration test",
    ),
]


@pytest.fixture(scope="module")
def model_and_tokenizer() -> tuple[AutoModelForCausalLM, AutoTokenizer]:
    """Load a small model for testing."""
    model_name = "Qwen/Qwen2.5-0.5B-Instruct"

    tokenizer = AutoTokenizer.from_pretrained(model_name)
    model = AutoModelForCausalLM.from_pretrained(
        model_name,
        torch_dtype=torch.float16,
        device_map="auto",
    )
    model.eval()

    return model, tokenizer


@pytest.fixture
def mock_wallet() -> Any:
    """Create a mock wallet for signing."""
    try:
        import bittensor as bt

        wallet = bt.wallet()
        wallet.create_new_coldkey(use_password=False, overwrite=True, suppress=True)
        wallet.create_new_hotkey(use_password=False, overwrite=True, suppress=True)
        return wallet
    except Exception as e:
        pytest.skip(f"Bittensor wallet creation failed: {e}")


def test_miner_proofs_pass_validator_verification(
    model_and_tokenizer: tuple[AutoModelForCausalLM, AutoTokenizer],
    mock_wallet: Any,
) -> None:
    """Test that miner-generated proofs pass validator's PROOF verification.

    Focused test ensuring:
    - Miner's forward passes produce valid GRAIL commitments
    - Validator's proof validator can verify those commitments
    - Hidden states match exactly between miner and validator

    Note: Tests only proof validation, not full pipeline (env prompt validation
    requires matching environment seeds which are complex to mock correctly).
    """
    from grail.environments.factory import create_env
    from grail.environments.loop import AgentEnvLoop
    from grail.protocol.signatures import sign_commit_binding
    from grail.shared.constants import ROLLOUTS_PER_PROBLEM
    from grail.validation.context import ValidationContext
    from grail.validation.validators.proof import GRAILProofValidator

    model, tokenizer = model_and_tokenizer
    device = str(model.device)

    window_hash = hashlib.sha256(b"test_window_hash").hexdigest()
    window_rand = hashlib.sha256(b"test_combined_randomness").hexdigest()

    # STEP 1: Miner generates GRPO rollouts with proofs
    print("\n=== MINER: Generating GRPO rollouts ===")
    loop = AgentEnvLoop(model, tokenizer, device)

    rollouts = loop.run_grpo_group(
        env_factory=lambda: create_env(),
        count=ROLLOUTS_PER_PROBLEM,
        randomness_hex=window_rand,
        wallet=mock_wallet,
        batch_size=4,
        seed=42,
    )

    assert len(rollouts) == ROLLOUTS_PER_PROBLEM
    print(f"✓ Generated {len(rollouts)} rollouts")

    # STEP 2: Validator verifies proofs
    print("\n=== VALIDATOR: Verifying proofs ===")
    proof_validator = GRAILProofValidator()

    passed = 0
    failed = 0

    for idx, rollout in enumerate(rollouts):
        # Sign commit binding (as production does)
        commit_sig = sign_commit_binding(
            tokens=rollout.tokens,
            randomness_hex=window_rand,
            model_name=model.name_or_path,
            layer_index=-1,
            commitments=rollout.commitments,
            wallet=mock_wallet,
        )

        commit_data = {
            "tokens": rollout.tokens,
            "commitments": rollout.commitments,
            "proof_version": rollout.proof_version,
            "model": {
                "name": model.name_or_path,
                "layer_index": -1,
            },
            "signature": commit_sig.hex(),
            "beacon": rollout.beacon,
            "rollout": {
                "prompt_length": rollout.prompt_length,
                "completion_length": rollout.completion_length,
            },
        }

        ctx = ValidationContext(
            commit=commit_data,
            prover_address=mock_wallet.hotkey.ss58_address,
            challenge_randomness=window_rand,
            window_hash=window_hash,
            group_index=0,
            miner_uid="test_miner",
            model=model,
            tokenizer=tokenizer,
            device=device,
        )

        # Test ONLY proof validation (not full pipeline)
        is_valid = proof_validator.validate(ctx)

        if is_valid:
            passed += 1
        else:
            failed += 1
            print(f"  ✗ Rollout {idx}: Proof verification FAILED")

    print(f"\n=== RESULTS: {passed}/{len(rollouts)} passed, {failed}/{len(rollouts)} failed ===")

    assert failed == 0, (
        f"Proof validation failed for {failed}/{len(rollouts)} rollouts. "
        "This indicates miner and validator compute different hidden states."
    )

    print("✓ All proofs validated successfully!")


def test_single_rollout_proof_cycle(
    model_and_tokenizer: tuple[AutoModelForCausalLM, AutoTokenizer],
    mock_wallet: Any,
) -> None:
    """Simplified single-rollout test for debugging."""
    from grail.environments.factory import create_env
    from grail.environments.loop import AgentEnvLoop
    from grail.validation.context import ValidationContext
    from grail.validation.validators.proof import GRAILProofValidator

    model, tokenizer = model_and_tokenizer
    device = str(model.device)
    window_rand = hashlib.sha256(b"test_randomness").hexdigest()

    # Generate single rollout
    loop = AgentEnvLoop(model, tokenizer, device)
    env = create_env()
    obs = env.reset(seed=42)
    prompts = [{"role": m.role, "content": m.content} for m in obs.messages]

    import asyncio

    results = asyncio.run(loop._batch_generate_tokens([prompts], include_logprobs=False))
    all_ids, prompt_len, _logprobs = results[0]

    # Compute commitments
    proof_results = loop._batch_compute_commitments_and_logprobs(
        [all_ids], [prompt_len], window_rand, mock_wallet
    )
    commitments, logprobs, _commit_sig, beacon, proof_version = proof_results[0]

    print(f"\n✓ Generated proof with {len(commitments)} commitments")

    # Sign commit binding (required for validator verification)
    from grail.protocol.signatures import sign_commit_binding

    commit_signature = sign_commit_binding(
        tokens=all_ids,
        randomness_hex=window_rand,
        model_name=model.name_or_path,
        layer_index=-1,
        commitments=commitments,
        wallet=mock_wallet,
    )

    # Validate proof
    commit_data = {
        "tokens": all_ids,
        "commitments": commitments,
        "proof_version": proof_version,
        "model": {"name": model.name_or_path, "layer_index": -1},
        "signature": commit_signature.hex(),
        "beacon": beacon,
        "rollout": {
            "prompt_length": prompt_len,
            "completion_length": len(all_ids) - prompt_len,
            "total_reward": 0.0,
            "advantage": 0.0,
            "success": False,
            "token_logprobs": [0.0] * prompt_len + logprobs,
            "trajectory": [],
            "assignment": [],
            "satisfied_clauses": 0,
        },
    }

    ctx = ValidationContext(
        commit=commit_data,
        prover_address=mock_wallet.hotkey.ss58_address,
        challenge_randomness=window_rand,
        window_hash=hashlib.sha256(b"test_hash").hexdigest(),
        group_index=0,
        miner_uid="test",
        model=model,
        tokenizer=tokenizer,
        device=device,
    )

    validator = GRAILProofValidator()
    is_valid = validator.validate(ctx)

    assert is_valid, f"Proof validation failed: {ctx.checks}"
    print("✓ Proof validated successfully!")


if __name__ == "__main__":
    pytest.main([__file__, "-v", "-s"])
